<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Stroboscope example</title>
</head>
<style>
input {
  width: 50px;
}
</style>
<body>
<h2>Stroboscope example</h2>
<div class="control">
  <button id="videoImport">Upload new video</button>          
  <input id="videoInput" type="file" accept="video/*,.mkv,.mov" hidden/>
  <button id="startAndStop" disabled>Start</button>
  <input id="frequency" type="number" step="1" value="1"></input>
  <input id="threshold" type="number" step="1" value="16"></input>
  <input id="history" type="number" step="1" value="5"></input>
  <input id="learningRate" type="number" value="-0.1"></input>
  <input id="nmixtures" type="number" value="5"></input>
  <input id="backgroudRatio" type="number" value="0.5"></input>
  <input id="twoPass" type="checkbox" checked></input>
  <input id="shadowThreshold" type="number" value="0.5"></input>
  <input id="skip" type="number" value="1"></input> <br/>
  <input id="varThresholdGen" type="number" value="9"></input>
  <input id="varInit" type="number" value="400"></input>
  <input id="varMin" type="number" value="4"></input>
  <input id="varMax" type="number" value="1600"></input>
  <input id="CRT" type="number" value="0.05"></input>
</div>
<div>
    <table cellpadding="0" cellspacing="0" width="0" border="0">
    <tr>
        <td>
            <video id="video" autoplay playsinline muted style="display:none;"></video>
            <canvas id="canvasVideo"></canvas>
        </td>
        <td>
            <canvas id="canvasOutput"></canvas>
        </td>
    </tr>
    <tr>
        <td>
            <canvas id="canvasOutput2"></canvas>
        </td>
        <td>
            <canvas id="canvasOutput3"></canvas>
        </td>
    </tr>
    </table>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<!--script async src="https://docs.opencv.org/4.5.2/opencv.js" id="opencv"></script-->  
<script async src="scripts/opencv_bgfg.js" id="opencv"></script>  

<script type="text/javascript">

let streaming = false;
let video = document.getElementById('video');
let canvasVideo     = document.getElementById('canvasVideo');
let canvasVideoCtx  = canvasVideo.getContext('2d');


let startAndStop = document.getElementById('startAndStop');
let canvasOutput = document.getElementById('canvasOutput');
let canvasContext = canvasOutput.getContext('2d');

const FPS = 30;

// Trigger click on videoInput when user clicks on menu item
$("#videoImport").click( () => {
      $("#videoInput").click();
});

// Add event listener for when file is selected
$("#videoInput").change( function() {

    // Get the file
    let URL = window.URL || window.webkitURL;
    let file = this.files[0];
    video.src = URL.createObjectURL(file);

    console.log("Imported video");

});

  // Prepare canvas size, calibration controls and set frame rate when meta data is available
video.addEventListener('loadedmetadata', () => {
    console.log("Loaded metadata");

      video.height = video.videoHeight;
      video.width = video.videoWidth;
      canvasVideo.width = video.videoWidth;
      canvasVideo.height = video.videoHeight;

    // Pause the video (needed because of autoplay)
    video.pause();

    $("#history").val( Math.round(FPS * video.duration) );

});

// Show the video when it has been loaded
video.addEventListener('loadeddata', () => {    
    //video.currentTime( 0 );
    console.log("Loaded video");
    canvasVideoCtx.drawImage(video,0,0);
});


startAndStop.addEventListener('click', () => {
    if (!streaming) {
      onVideoStarted();
    } else {
        onVideoStopped();
    }
});

function onVideoStarted() {
      streaming = true;
      video.height = video.videoHeight;
      video.width = video.videoWidth;
      canvasVideo.width = video.videoWidth;
      canvasVideo.height = video.videoHeight;
      startAndStop.innerText = 'Stop';
      loadRest();    
}

function onVideoStopped() {
    streaming = false;
    video.currentTime = 0;
    //canvasContext.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
    startAndStop.innerText = 'Start';
}

document.getElementById('opencv').onload = function () {
  console.log("OpenCV is ready");
  video.addEventListener('canplay', () => {
        startAndStop.removeAttribute('disabled');
  });
  // Use this with: python3 -m http.server --cgi 8080
  //video.src="demo_bounching_ball.mp4";
  //console.log(video);
  if( window.cv instanceof Promise ) {
    console.log("cv returns a promise");
    window.cv.then((target) => {
      window.cv = target;
      console.log( target );
    })
  }
  
};


let masks = [];
let fgmasks = [];
let bgMat;

$("#skip").change( function() {
  showResult( parseInt($(this).val()) ); 
});

function showResult(nSkip) {

  let newResult = new cv.Mat(video.height, video.width, cv.CV_8UC4);//bgMat.clone();
  //console.log( bgMat.type() );
  cv.cvtColor( bgMat, newResult, cv.COLOR_BGR2BGRA );
  //new cv.Mat(video.height, video.width, cv.CV_8UC3);
  for( let i=0; i < masks.length && nSkip > 0; i += nSkip ) {
    masks[i].copyTo(newResult, masks[i]);
    //console.log("shadow= " + i);
  }
  cv.imshow('canvasOutput3', newResult);

  for( let j=0; j < fgmasks.length && nSkip > 0; j += nSkip ) {
    fgmasks[j].copyTo(newResult, fgmasks[j]);
    //console.log("foregr= " + i);
  }

  cv.imshow('canvasOutput3', newResult);
  newResult.delete();

}


function loadRest() {


// take first frame of the video
let frameRGB = new cv.Mat();
let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
canvasVideoCtx.drawImage(video,0,0);
let result = cv.imread('canvasVideo');
//let cap = new cv.VideoCapture(video);
//let result = new cv.Mat(video.height, video.width, cv.CV_8UC4);
//cap.read(result);


let fgResult = new cv.Mat(video.height, video.width, cv.CV_8UC3);

bgMat = new cv.Mat(video.height, video.width, cv.CV_8UC3);

let mask = new cv.Mat(video.height, video.width, cv.CV_8UC1);
let fgmask = new cv.Mat(video.height, video.width, cv.CV_8UC1);
//let shadowmask = new cv.Mat(video.height, video.width, cv.CV_8UC1);

masks = [];
fgmasks = [];

let f = parseInt($("#frequency").val());
let threshold = parseFloat($("#threshold").val());
let history = Math.round( 2 * parseInt($("#history").val()) / f );
let fgbg = new cv.BackgroundSubtractorMOG2(history, threshold, true);
//console.log(fgbg);

let lrInput = parseFloat($("#learningRate").val());
//let lr = 1; // Only for first frame
let lr=lrInput;

let i = 0;
let firstPass = $('#twoPass').is(':checked');

//let firstPass = false; // No second pass

console.log("Best lr=" + 1/(FPS*video.duration) + " (used lr="+lr+")");
fgbg.setNMixtures( parseFloat($("#nmixtures").val()) ); 
console.log("nmixtures= "+ fgbg.getNMixtures() );
fgbg.setBackgroundRatio( parseFloat($("#backgroudRatio").val()) ); 
console.log("backgroudRatio= "+ fgbg.getBackgroundRatio() );

fgbg.setShadowThreshold( parseFloat($("#shadowThreshold").val()) ); 
console.log("ShadowThreshold= "+ fgbg.getShadowThreshold() );

fgbg.setVarThresholdGen( parseFloat($("#varThresholdGen").val()) ); 
fgbg.setVarInit( parseFloat($("#varInit").val()) ); 
fgbg.setVarMin( parseFloat($("#varMin").val()) ); 
fgbg.setVarMax( parseFloat($("#varMax").val()) ); 
fgbg.setComplexityReductionThreshold( parseFloat($("#CRT").val()) ); 


function processVideo() {
    try {
        if (!streaming) {
            // clean and stop.
            //console.log("Stopping streaming");
            console.log( "i = " + i);
            console.log("nmixtures= "+ fgbg.getNMixtures() );

            fgResult.copyTo(result, fgResult);

            cv.imshow('canvasOutput3', result);
            frame.delete(); mask.delete(); fgbg.delete();result.delete();
            return;
        }
        //let begin = Date.now();
        // start processing.
        frame = cv.imread('canvasVideo');

        // See: https://github.com/opencv/opencv/issues/17206
        cv.cvtColor(frame, frameRGB, cv.COLOR_RGBA2RGB);

        //cv.medianBlur(frameRGB, frameRGB, 3);

        //cap.read(frame);

        //if( firstPass && i>0 ) lr = lrInput;

        //if( i%f == 0 ) {
          fgbg.apply(frameRGB, mask, lr);

          //let fgmask2

          if( !firstPass ) {
            cv.threshold(mask, fgmask, 200, 255, cv.THRESH_BINARY);

            //let fgmask2 = new cv.Mat(video.height, video.width, cv.CV_8UC1);
            //let M = cv.Mat.ones(2, 2, cv.CV_8U);
            //cv.erode(fgmask, fgmask, M);
            //cv.dilate(fgmask, fgmask, M);
            //cv.threshold(fgmask, fgmask, 100, 255, cv.THRESH_BINARY);
            
            //cv.bilateralFilter(fgmask, fgmask, 9, 150, 175, cv.BORDER_DEFAULT);
            //cv.medianBlur(fgmask, fgmask, 3);

            frame.copyTo(fgResult, fgmask);

            let fgtemp = new cv.Mat(video.height, video.width, cv.CV_8UC4, [0, 0, 0, 255]);
            frame.copyTo(fgtemp, fgmask);
            let temp = new cv.Mat(video.height, video.width, cv.CV_8UC4, [0, 0, 0, 255]);

            frame.copyTo(temp, mask);

                      //cv.imshow('canvasOutput2', temp);

            masks.push( temp );
            fgmasks.push( fgtemp );

            //cv.bitwise_xor(mask, fgmask, shadowmask, mask);
            //frame.copyTo(result, shadowmask);
            frame.copyTo(result, mask);

          //cv.imshow('canvasOutput', fgmask2);

          }

          cv.imshow('canvasOutput', mask);
          fgbg.getBackgroundImage(bgMat);
          cv.imshow('canvasOutput2', bgMat);
          //console.log("i=" + i);

          // Temporary end here
          /*if( !firstPass && i==0 ) {
            onVideoStopped();
            cv.imshow('canvasOutput3', result);
            frame.delete(); mask.delete(); fgbg.delete();result.delete();
            return;            
          }*/
        //}

        // schedule the next one.
        let delay = 0;//1000/FPS - (Date.now() - begin);
        i += Math.round(f);
        //setTimeout(processVideo, delay);
        if( i/FPS > video.duration ) {
          if( firstPass ) {
            firstPass = false;
            i = 0;
            // Set the next iteration to zero
            lr = 0.0;
            //console.log("threshold= " + fgbg.getVarThreshold(  ));
          } else {
            onVideoStopped();
          }
        }
        video.currentTime = i/FPS ;

        video.addEventListener("seeked", function(e) {
          // remove the handler or else it will draw another frame on the same canvas in next seek
          e.target.removeEventListener(e.type, arguments.callee); 
          canvasVideoCtx.drawImage(video,0,0);
          setTimeout(processVideo, delay);
       
        });

    } catch (err) {
       console.error('There was an error:', err);
        //utils.printError(err);
       console.log(cv.exceptionFromPtr(err).msg);
    }
};

//video.play();
// schedule the first one.
video.currentTime = 0 ;
        video.addEventListener("seeked", function(e) {
          // remove the handler or else it will draw another frame on the same canvas in next seek
          e.target.removeEventListener(e.type, arguments.callee); 
          canvasVideoCtx.drawImage(video,0,0);
          result = cv.imread('canvasVideo');
          setTimeout(processVideo, 0);
       
        });



};

</script>
</body>
</html>

