<!DOCTYPE html>
<html>
<body>

<div style="display: inline-block; margin-left: 10px">
  <button id="dragmode" class="btn btn-info">Pointer</button>
  <button id="pencil" class="btn btn-info">Pencil</button>
  <button id="eraser" class="btn btn-info">Eraser</button>
  <button id="clear-canvas" class="btn btn-info">Clear</button>
  <button id="pointer" class="btn btn-info">Select</button>
  <button id="undo" class="btn btn-info">Undo</button>
  <button id="redo" class="btn btn-info">Redo</button>


  <button id="black" class="btn color" style="background-color:black">B</button>
  <button id="red" class="btn color" style="background-color:red">R</button>
  <button id="green" class="btn color" style="background-color:green">G</button>
  <button id="blue" class="btn color" style="background-color:blue">B</button>





  <label for="drawing-line-width">Line width:</label>
  <span class="info">2</span><input type="range" value="2" min="0" max="10" id="drawing-line-width">

  <label for="drawing-color">Line color:</label>
  <input type="color" value="#000000" id="drawing-color">
  <a href="" onclick="screenshot(this)">Screenshot</a>
</div>
    <script src="scripts/fabric.min.js"></script>
    <script src="scripts/jquery-3.5.0.min.js"></script>

   <div id="canvas1" style="position:relative;width:100px;height:100px;top:0px; left:0px">
      <canvas id="c" width="100" height="100" style="border:1px solid #ccc">
        Your browser does not support HTML5 Canvas.
      </canvas>
   </div>

<script id="main">
  
  
  //(function() {

  var dom = function(id){return document.getElementById(id)};

  var canvas = this.__canvas = new fabric.Canvas('c', {
    isDrawingMode: true,
    isDeleteMode: false,
    redoList: []
  });

  fabric.Object.prototype.transparentCorners = false;
  fabric.Object.prototype.hasControls = false;
  fabric.Object.prototype.hasBorders = false;
  fabric.Object.prototype.padding = 10;

const STATE_IDLE = 'idle';
const STATE_PANNING = 'panning';
fabric.Canvas.prototype.toggleDragMode = function(dragMode) {
  // Remember the previous X and Y coordinates for delta calculations
  let lastClientX;
  let lastClientY;
  // Keep track of the state
  let state = STATE_IDLE;
  // We're entering dragmode
  if (dragMode) {
    // Discard any active object
    this.discardActiveObject();
    // Set the cursor to 'move'
    this.defaultCursor = 'move';
    // Loop over all objects and disable events / selectable. We remember its value in a temp variable stored on each object
    this.forEachObject(function(object) {
      object.prevEvented = object.evented;
      object.prevSelectable = object.selectable;
      object.evented = false;
      object.selectable = false;
    });
    // Remove selection ability on the canvas
    this.selection = false;
    // When MouseUp fires, we set the state to idle
    this.on('mouse:up', function(e) {
      state = STATE_IDLE;
    });
    // When MouseDown fires, we set the state to panning
    this.on('mouse:down', (e) => {
      state = STATE_PANNING;
      lastClientX = e.e.clientX;
      lastClientY = e.e.clientY;
    });
    // When the mouse moves, and we're panning (mouse down), we continue
    this.on('mouse:move', (e) => {
      if (state === STATE_PANNING && e && e.e) {
        // let delta = new fabric.Point(e.e.movementX, e.e.movementY); // No Safari support for movementX and movementY
        // For cross-browser compatibility, I had to manually keep track of the delta

        // Calculate deltas
        let deltaX = 0;
        let deltaY = 0;
        if (lastClientX) {
          deltaX = e.e.clientX - lastClientX;
        }
        if (lastClientY) {
          deltaY = e.e.clientY - lastClientY;
        }
        // Update the last X and Y values
        lastClientX = e.e.clientX;
        lastClientY = e.e.clientY;

        let delta = new fabric.Point(deltaX, deltaY);
        this.relativePan(delta);
        this.trigger('moved');
      }
    });
  } else {
    // When we exit dragmode, we restore the previous values on all objects
    this.forEachObject(function(object) {
      object.evented = (object.prevEvented !== undefined) ? object.prevEvented : object.evented;
      object.selectable = (object.prevSelectable !== undefined) ? object.prevSelectable : object.selectable;
    });
    // Reset the cursor
    this.defaultCursor = 'default';
    // Remove the event listeners
    this.off('mouse:up');
    this.off('mouse:down');
    this.off('mouse:move');
    // Restore selection ability on the canvas
    this.selection = true;
    
    // Event listener: remove the element
    canvas.on('mouse:up', function(e) {
      var p = e.target;
      if( canvas.isDeleteMode && p ) {
        canvas.remove(p);
      }
    });


    
  }
};
  
  
  
  
  dom('clear-canvas').onclick = function() { canvas.clear() };

  dom('pointer').onclick = function() {
    canvas.isDrawingMode = false;
    canvas.isDeleteMode = false;
    canvas.toggleDragMode(false);
    fabric.Object.prototype.hasControls = true;
    fabric.Object.prototype.hasBorders = true;
    /*if (canvas.isDrawingMode) {
      dom('pointer').innerHTML = 'Pointer';
    }*/
  };

  dom('pencil').onclick = function() {
    canvas.isDrawingMode = true;
    canvas.isDeleteMode = false;
    canvas.toggleDragMode(false);
  };    
    
  dom('drawing-color').onchange = function() {
    var brush = canvas.freeDrawingBrush;
    brush.color = this.value;
    console.log(this.value)
  };

  dom('black').onclick = function() { canvas.freeDrawingBrush.color = "black"; };
  dom('red').onclick = function() { canvas.freeDrawingBrush.color = "red"; };
  dom('green').onclick = function() { canvas.freeDrawingBrush.color = "green"; };
  dom('blue').onclick = function() { canvas.freeDrawingBrush.color = "blue"; };

  
  dom('drawing-line-width').onchange = function() {
    canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
    this.previousSibling.innerHTML = this.value;
  };

  dom('eraser').onclick = function() { 
    canvas.isDrawingMode = false;
    canvas.isDeleteMode = true;
    canvas.toggleDragMode(false);
  };
    
  if (canvas.freeDrawingBrush) {
    canvas.freeDrawingBrush.color = dom('drawing-color').value;
    canvas.freeDrawingBrush.width = parseInt(dom('drawing-line-width').value, 10) || 1;
  }
    
  // Event listener: remove the element
  canvas.on('mouse:up', function(e) {
    var p = e.target;
    if( canvas.isDeleteMode && p ) {
      canvas.remove(p);
    }
  });

  
  dom('undo').onclick = function() { 
    var canvas_objects = canvas._objects;
    if(canvas_objects.length !== 0){
      var last = canvas_objects[canvas_objects.length -1]; //Get last object
      canvas.redoList.push(last);
      canvas.remove(last);
      canvas.renderAll();
    }
  }

  dom('redo').onclick = function() { 
    //var canvas_objects = canvas._objects;
    if(canvas.redoList.length !== 0){
      var last = canvas.redoList[canvas.redoList.length -1]; //Get last object
      canvas.add(last);
      canvas.renderAll();
    }
  }

  // update the redo-list
  canvas.on('object:added', function(e) {
    if(canvas.redoList.length !== 0){
      var last = canvas.redoList[canvas.redoList.length -1]; //Get last object
      if(e.target == last) {  
        canvas.redoList.pop();
      } else {
        canvas.redoList = [];
      }
    }
   });
  
  


// Create the canvas

//let canvas = new fabric.Canvas('fabric')
//canvas.backgroundColor = '#f1f1f1';

// Add a couple of rects

/*let rect = new fabric.Rect({
  width: 100,
  height: 100,
  fill: '#f00'
});
canvas.add(rect)

rect = new fabric.Rect({
  width: 200,
  height: 200,
  top: 200,
  left: 200,
  fill: '#f00'
});
canvas.add(rect)
*/
// Handle dragmode change
//let dragMode = false;
dom('dragmode').onclick = function() {
  //dragMode = !dragMode;
  canvas.toggleDragMode(true);
  canvas.isDrawingMode = false;
  canvas.isDeleteMode = false;
}
  
  // Make a screenshot
  function screenshot(htmlElement) {
    var image = canvas.toDataURL({format: 'png', multiplier: 2});  
    htmlElement.setAttribute("download","screenshot.png");
    htmlElement.setAttribute("href", image);
  }  
    
  // Event listener for resizing the window
  //window.addEventListener('resize', resizeCanvas, false);
  $(window).resize( resizeCanvas );
  function resizeCanvas() {    
    var divCanvas = document.getElementById("canvas1");
    var newWidth = window.innerWidth-20;
    if( newWidth > 100 ) { // minimum size needs to stay at 100px
      divCanvas.style.width = newWidth;
      canvas.setWidth(newWidth);
      canvas.renderAll();
    }
    var newHeight = window.innerHeight-50;
    console.log(newHeight);
    if( newHeight > 100 ) { // minimum size needs to stay at 100px
      divCanvas.style.height = newHeight;
      canvas.setHeight(newHeight);
      canvas.renderAll();
    }

  }
  
  //console.log(canvas);
  
  // load all code after the document
  $("document").ready(function(){
    // resize on init
    resizeCanvas();
  });

//})();
   
  </script>

    <noscript>Your browser does not support JavaScript!</noscript>

  
</body>
</html>
